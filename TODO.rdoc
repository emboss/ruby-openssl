== OpenSSL::ASN1::Template

=== asn1_sequence_of_choice, asn1_set_of_choice 

Either provide the DSL methods or allow to declare a template as a choice
via asn1_declare_choice. If the latter is implemented, the prior methods
could be provided by creating a temporary choice type that is attached to
the ordinary asn1_sequence_of and asn1_set_of. the *of_choice methods might
come in handy in situations where the namespace should not be polluted by 
being forced to create a template for an otherwise useless ASN.1 construct.

=== Infinite length

* convert infinite length primitives to a single primitive
* infinite length should only be a hint for encoding, primitive values should always
  be converted to a single distinct value (instead of an array)
* TBD: infinite_length should not be a static choice that is set within a template's
  definition, it should be rather decided on a per-instance basis whether certain
  values are to be encoded as infinite length or not. This could be handled by monkey-
  patching the parsed values with instance variables. One would be a flag, that determines
  if infinite length shall be applied or not, another one determines the chunk sizes for 
  primitive encodings. On encoding such a template instance, the opportunity to declare 
  which elements should be encoded as infinite length values (and possibly also
  the chunk sizes) should exist (function parameter, separate function, block?)
* the above points imply removing the infinite_length option from the template definition

=== Multi-threaded parsing

* Sequences and sets could be parsed using threads from a thread pool to boost performance

=== No top-level optional for choices? (Except if they're declared as a separate type)

=== Tests 

* Tests for default of asn1_any

* Tests for default of asn1_sequence_of, asn1_set_of

* Tests for default with template encoding / parsing

* Test scenarios for "optional"

* Test for optional of constructive, constructive_of and template
  
  If the top-level construct is declared optional, parsing and encoding
  must behave as follows: if the top-level construct (e.g. Sequence) is
  missing, it must succeed, but if it's there, then the "inner rules"
  regarding optional must apply, i.e. it must not be that all inner 
  objects suddenly become optional

* Infinite length for primitives

* Infinite length for constructed values

* Infinite length with explicit tagging

* Infinite length with implicit tagging

* asn1_any with infinite length

=== String encoders

Introduce encoders that force a certain encoding that is specific to the string type?


